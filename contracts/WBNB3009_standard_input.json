{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/AIOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title AIOracle\r\n * @dev AI-assisted oracle for fast prediction market resolution\r\n * @notice Implements YZi Labs track: domain-specific AI-assisted oracles\r\n */\r\ncontract AIOracle is Ownable {\r\n    struct ResolutionRequest {\r\n        uint256 marketId;\r\n        string dataSource;\r\n        uint256 timestamp;\r\n        bool resolved;\r\n        bool outcome;\r\n        uint256 confidence; // 0-10000 (0-100%)\r\n        string evidenceHash; // IPFS hash of evidence\r\n    }\r\n\r\n    struct DataSource {\r\n        string name;\r\n        string apiEndpoint;\r\n        bool active;\r\n        uint256 successRate; // Historical success rate\r\n    }\r\n\r\n    mapping(uint256 => ResolutionRequest) public resolutionRequests;\r\n    mapping(string => DataSource) public dataSources;\r\n    mapping(address => bool) public aiAgents;\r\n\r\n    address public predictionMarketContract;\r\n    uint256 public requestCount;\r\n    uint256 public constant MIN_CONFIDENCE = 8000; // 80% minimum confidence\r\n\r\n    event ResolutionRequested(\r\n        uint256 indexed requestId,\r\n        uint256 indexed marketId,\r\n        string dataSource\r\n    );\r\n\r\n    event ResolutionProvided(\r\n        uint256 indexed requestId,\r\n        bool outcome,\r\n        uint256 confidence\r\n    );\r\n\r\n    event DataSourceAdded(string name, string apiEndpoint);\r\n\r\n    constructor(address _predictionMarketContract) Ownable(msg.sender) {\r\n        predictionMarketContract = _predictionMarketContract;\r\n        \r\n        // Initialize default data sources\r\n        _addDataSource(\"CoinGecko\", \"https://api.coingecko.com/api/v3\");\r\n        _addDataSource(\"Binance\", \"https://api.binance.com/api/v3\");\r\n        _addDataSource(\"OpenAI\", \"https://api.openai.com/v1\");\r\n    }\r\n\r\n    /**\r\n     * @dev Request AI-assisted resolution for a market\r\n     */\r\n    function requestResolution(uint256 _marketId, string memory _dataSource) \r\n        external \r\n    {\r\n        require(bytes(_dataSource).length > 0, \"Data source required\");\r\n        require(dataSources[_dataSource].active, \"Data source not active\");\r\n\r\n        requestCount++;\r\n        resolutionRequests[requestCount] = ResolutionRequest({\r\n            marketId: _marketId,\r\n            dataSource: _dataSource,\r\n            timestamp: block.timestamp,\r\n            resolved: false,\r\n            outcome: false,\r\n            confidence: 0,\r\n            evidenceHash: \"\"\r\n        });\r\n\r\n        emit ResolutionRequested(requestCount, _marketId, _dataSource);\r\n    }\r\n\r\n    /**\r\n     * @dev Provide AI-generated resolution (called by authorized AI agents)\r\n     */\r\n    function provideResolution(\r\n        uint256 _requestId,\r\n        bool _outcome,\r\n        uint256 _confidence,\r\n        string memory _evidenceHash\r\n    ) external {\r\n        require(aiAgents[msg.sender], \"Not authorized AI agent\");\r\n        require(!resolutionRequests[_requestId].resolved, \"Already resolved\");\r\n        require(_confidence >= MIN_CONFIDENCE, \"Confidence too low\");\r\n\r\n        ResolutionRequest storage request = resolutionRequests[_requestId];\r\n        request.resolved = true;\r\n        request.outcome = _outcome;\r\n        request.confidence = _confidence;\r\n        request.evidenceHash = _evidenceHash;\r\n\r\n        emit ResolutionProvided(_requestId, _outcome, _confidence);\r\n    }\r\n\r\n    /**\r\n     * @dev Get resolution status for a market\r\n     */\r\n    function getResolutionStatus(uint256 _marketId) \r\n        external \r\n        view \r\n        returns (\r\n            bool pending,\r\n            uint256 confidence,\r\n            bool suggestedOutcome,\r\n            string memory evidenceHash\r\n        ) \r\n    {\r\n        for (uint256 i = 1; i <= requestCount; i++) {\r\n            ResolutionRequest storage req = resolutionRequests[i];\r\n            if (req.marketId == _marketId) {\r\n                return (\r\n                    !req.resolved,\r\n                    req.confidence,\r\n                    req.outcome,\r\n                    req.evidenceHash\r\n                );\r\n            }\r\n        }\r\n        return (false, 0, false, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new data source\r\n     */\r\n    function addDataSource(string memory _name, string memory _apiEndpoint) \r\n        external \r\n        onlyOwner \r\n    {\r\n        _addDataSource(_name, _apiEndpoint);\r\n    }\r\n\r\n    function _addDataSource(string memory _name, string memory _apiEndpoint) \r\n        internal \r\n    {\r\n        dataSources[_name] = DataSource({\r\n            name: _name,\r\n            apiEndpoint: _apiEndpoint,\r\n            active: true,\r\n            successRate: 10000 // 100% initial\r\n        });\r\n        emit DataSourceAdded(_name, _apiEndpoint);\r\n    }\r\n\r\n    /**\r\n     * @dev Set AI agent authorization\r\n     */\r\n    function setAIAgent(address _agent, bool _authorized) \r\n        external \r\n        onlyOwner \r\n    {\r\n        aiAgents[_agent] = _authorized;\r\n    }\r\n\r\n    /**\r\n     * @dev Update data source status\r\n     */\r\n    function updateDataSource(\r\n        string memory _name,\r\n        bool _active,\r\n        uint256 _successRate\r\n    ) external onlyOwner {\r\n        DataSource storage ds = dataSources[_name];\r\n        require(bytes(ds.name).length > 0, \"Data source does not exist\");\r\n        ds.active = _active;\r\n        ds.successRate = _successRate;\r\n    }\r\n}\r\n"
    },
    "contracts/GaslessRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title GaslessRelayer\r\n * @dev Meta-transaction relayer for gasless user experience\r\n * @notice Implements YZi Labs track: account abstraction and gasless UX\r\n */\r\ncontract GaslessRelayer is Ownable, ReentrancyGuard {\r\n    struct MetaTransaction {\r\n        address from;\r\n        address to;\r\n        uint256 value;\r\n        bytes data;\r\n        uint256 nonce;\r\n        uint256 deadline;\r\n    }\r\n\r\n    mapping(address => uint256) public nonces;\r\n    mapping(address => bool) public whitelistedContracts;\r\n    mapping(address => uint256) public userGasCredits;\r\n    \r\n    uint256 public constant GAS_CREDIT_PER_USER = 10; // Free transactions per user\r\n    \r\n    event MetaTransactionExecuted(\r\n        address indexed user,\r\n        address indexed target,\r\n        bool success\r\n    );\r\n    \r\n    event GasCreditsAdded(address indexed user, uint256 credits);\r\n\r\n    constructor() Ownable(msg.sender) {}\r\n\r\n    /**\r\n     * @dev Execute a meta-transaction (gasless for user)\r\n     */\r\n    function executeMetaTransaction(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external nonReentrant returns (bool) {\r\n        require(block.timestamp <= _deadline, \"Transaction expired\");\r\n        require(whitelistedContracts[_to], \"Contract not whitelisted\");\r\n        require(\r\n            userGasCredits[_from] > 0,\r\n            \"No gas credits remaining\"\r\n        );\r\n\r\n        // Verify signature\r\n        bytes32 messageHash = keccak256(\r\n            abi.encodePacked(\r\n                _from,\r\n                _to,\r\n                _value,\r\n                _data,\r\n                nonces[_from],\r\n                _deadline\r\n            )\r\n        );\r\n        \r\n        bytes32 ethSignedHash = keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\r\n        );\r\n        \r\n        address signer = ecrecover(ethSignedHash, _v, _r, _s);\r\n        require(signer == _from, \"Invalid signature\");\r\n        \r\n        // Increment nonce\r\n        nonces[_from]++;\r\n        \r\n        // Deduct gas credit\r\n        userGasCredits[_from]--;\r\n        \r\n        // Execute transaction\r\n        (bool success, ) = _to.call{value: _value}(_data);\r\n        \r\n        emit MetaTransactionExecuted(_from, _to, success);\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @dev Add gas credits for a user (sponsor can pay)\r\n     */\r\n    function addGasCredits(address _user, uint256 _credits) \r\n        external \r\n        onlyOwner \r\n    {\r\n        userGasCredits[_user] += _credits;\r\n        emit GasCreditsAdded(_user, _credits);\r\n    }\r\n\r\n    /**\r\n     * @dev Whitelist a contract for gasless interactions\r\n     */\r\n    function setWhitelistedContract(address _contract, bool _whitelisted) \r\n        external \r\n        onlyOwner \r\n    {\r\n        whitelistedContracts[_contract] = _whitelisted;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize new users with free gas credits\r\n     */\r\n    function initializeUser(address _user) external {\r\n        if (userGasCredits[_user] == 0) {\r\n            userGasCredits[_user] = GAS_CREDIT_PER_USER;\r\n            emit GasCreditsAdded(_user, GAS_CREDIT_PER_USER);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fund the relayer (for gas costs)\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev Withdraw funds (only owner)\r\n     */\r\n    function withdraw(uint256 _amount) external onlyOwner {\r\n        require(address(this).balance >= _amount, \"Insufficient balance\");\r\n        (bool success, ) = owner().call{value: _amount}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n    }\r\n}\r\n"
    },
    "contracts/MockERC20WithAuth.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title MockERC20WithAuth\r\n * @dev Mock ERC20 token with EIP-3009 transferWithAuthorization for testing\r\n */\r\ncontract MockERC20WithAuth is ERC20 {\r\n    uint8 private _decimals;\r\n    \r\n    // EIP-3009 tracking\r\n    mapping(address => mapping(bytes32 => bool)) public authorizationState;\r\n    \r\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\r\n    \r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals_\r\n    ) ERC20(name, symbol) {\r\n        _decimals = decimals_;\r\n    }\r\n    \r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function mint(address to, uint256 amount) external {\r\n        _mint(to, amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev EIP-3009 transferWithAuthorization\r\n     * Simplified version for testing - real implementation would verify signature\r\n     */\r\n    function transferWithAuthorization(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external {\r\n        require(block.timestamp >= validAfter, \"Authorization not yet valid\");\r\n        require(block.timestamp <= validBefore, \"Authorization expired\");\r\n        require(!authorizationState[from][nonce], \"Authorization already used\");\r\n        require(balanceOf(from) >= value, \"Insufficient balance\");\r\n        \r\n        // Mark nonce as used\r\n        authorizationState[from][nonce] = true;\r\n        emit AuthorizationUsed(from, nonce);\r\n        \r\n        // Execute transfer\r\n        _transfer(from, to, value);\r\n    }\r\n}\r\n"
    },
    "contracts/PredictionMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./TraderReputation.sol\";\r\n\r\n/**\r\n * @title PredictionMarket\r\n * @dev Decentralized prediction market on BNB Chain with AI-assisted oracle integration\r\n * @notice Built for Seedify Hackathon 2025 - Now with on-chain reputation and copy trading\r\n */\r\ncontract PredictionMarket is ReentrancyGuard, Ownable {\r\n    struct Market {\r\n        uint256 id;\r\n        string question;\r\n        string description;\r\n        string category;\r\n        address creator;\r\n        uint256 endTime;\r\n        uint256 totalYesAmount;\r\n        uint256 totalNoAmount;\r\n        bool resolved;\r\n        bool outcome;\r\n        uint256 resolvedAt;\r\n        bool aiOracleEnabled;\r\n    }\r\n\r\n    struct Position {\r\n        uint256 yesAmount;\r\n        uint256 noAmount;\r\n        bool claimed;\r\n    }\r\n\r\n    // State variables\r\n    uint256 public marketCount;\r\n    uint256 public constant PLATFORM_FEE = 200; // 2% fee (in basis points)\r\n    uint256 public constant MIN_BET = 0.001 ether; // 0.001 BNB minimum bet\r\n    uint256 public constant MIN_REPUTATION_TO_CREATE = 50; // Minimum reputation score to create markets\r\n    \r\n    TraderReputation public reputationContract;\r\n    \r\n    mapping(uint256 => Market) public markets;\r\n    mapping(uint256 => mapping(address => Position)) public positions;\r\n    mapping(address => bool) public authorizedOracles;\r\n    \r\n    // Events\r\n    event MarketCreated(\r\n        uint256 indexed marketId,\r\n        string question,\r\n        uint256 endTime,\r\n        address indexed creator\r\n    );\r\n    \r\n    event PositionTaken(\r\n        uint256 indexed marketId,\r\n        address indexed user,\r\n        bool position,\r\n        uint256 amount\r\n    );\r\n    \r\n    event MarketResolved(\r\n        uint256 indexed marketId,\r\n        bool outcome,\r\n        uint256 resolvedAt\r\n    );\r\n    \r\n    event WinningsClaimed(\r\n        uint256 indexed marketId,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n\r\n    constructor() Ownable(msg.sender) {\r\n        // Initialize with deployer as authorized oracle\r\n        authorizedOracles[msg.sender] = true;\r\n        \r\n        // Deploy reputation contract with this contract as owner\r\n        reputationContract = new TraderReputation(address(this));\r\n    }\r\n    \r\n    /**\r\n     * @dev Set reputation contract address (for existing deployments)\r\n     */\r\n    function setReputationContract(address _reputationContract) external onlyOwner {\r\n        reputationContract = TraderReputation(_reputationContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new prediction market\r\n     */\r\n    function createMarket(\r\n        string memory _question,\r\n        string memory _description,\r\n        string memory _category,\r\n        uint256 _endTime,\r\n        bool _aiOracleEnabled\r\n    ) external returns (uint256) {\r\n        require(_endTime > block.timestamp, \"End time must be in the future\");\r\n        require(bytes(_question).length > 0, \"Question cannot be empty\");\r\n        \r\n        // Check reputation requirement (owner bypasses this)\r\n        if (address(reputationContract) != address(0) && msg.sender != owner()) {\r\n            uint256 reputation = reputationContract.getReputationScore(msg.sender);\r\n            require(reputation >= MIN_REPUTATION_TO_CREATE, \"Insufficient reputation to create markets. Place predictions to earn reputation.\");\r\n        }\r\n\r\n        marketCount++;\r\n        uint256 marketId = marketCount;\r\n\r\n        markets[marketId] = Market({\r\n            id: marketId,\r\n            question: _question,\r\n            description: _description,\r\n            category: _category,\r\n            creator: msg.sender,\r\n            endTime: _endTime,\r\n            totalYesAmount: 0,\r\n            totalNoAmount: 0,\r\n            resolved: false,\r\n            outcome: false,\r\n            resolvedAt: 0,\r\n            aiOracleEnabled: _aiOracleEnabled\r\n        });\r\n\r\n        emit MarketCreated(marketId, _question, _endTime, msg.sender);\r\n        return marketId;\r\n    }\r\n\r\n    /**\r\n     * @dev Buy a position in a market (YES or NO)\r\n     */\r\n    function buyPosition(uint256 _marketId, bool _position) \r\n        external \r\n        payable \r\n        nonReentrant \r\n    {\r\n        _buyPositionInternal(_marketId, _position, msg.sender, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev Buy position for user (called by x402 facilitator for gasless betting)\r\n     */\r\n    function buyPositionForUser(\r\n        uint256 _marketId,\r\n        bool _position,\r\n        address user\r\n    ) external payable nonReentrant {\r\n        // Only authorized x402 contracts can call this\r\n        require(authorizedOracles[msg.sender], \"Not authorized\");\r\n        _buyPositionInternal(_marketId, _position, user, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to buy position (supports both regular and gasless)\r\n     */\r\n    function _buyPositionInternal(\r\n        uint256 _marketId,\r\n        bool _position,\r\n        address user,\r\n        uint256 amount\r\n    ) internal {\r\n        Market storage market = markets[_marketId];\r\n        require(market.id != 0, \"Market does not exist\");\r\n        require(!market.resolved, \"Market already resolved\");\r\n        require(block.timestamp < market.endTime, \"Market has ended\");\r\n        require(amount >= MIN_BET, \"Bet amount too low\");\r\n\r\n        Position storage userPosition = positions[_marketId][user];\r\n\r\n        if (_position) {\r\n            userPosition.yesAmount += amount;\r\n            market.totalYesAmount += amount;\r\n        } else {\r\n            userPosition.noAmount += amount;\r\n            market.totalNoAmount += amount;\r\n        }\r\n\r\n        emit PositionTaken(_marketId, user, _position, amount);\r\n        \r\n        // Record bet in reputation contract\r\n        if (address(reputationContract) != address(0)) {\r\n            reputationContract.recordBet(user, _marketId, amount, _position);\r\n            \r\n            // Check for copy traders and execute copy trades\r\n            _executeCopyTrades(_marketId, user, _position, amount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Execute copy trades for followers\r\n     */\r\n    function _executeCopyTrades(\r\n        uint256 _marketId,\r\n        address trader,\r\n        bool _position,\r\n        uint256 amount\r\n    ) internal {\r\n        address[] memory traderFollowers = reputationContract.getFollowers(trader);\r\n        \r\n        for (uint256 i = 0; i < traderFollowers.length; i++) {\r\n            address follower = traderFollowers[i];\r\n            \r\n            // Get copy trade settings\r\n            (\r\n                uint256 maxAmountPerTrade,\r\n                uint256 copyPercentage,\r\n                bool active,\r\n                ,\r\n                \r\n            ) = reputationContract.getCopyTradeSettings(follower, trader);\r\n            \r\n            if (!active) continue;\r\n            \r\n            // Calculate copy amount\r\n            uint256 copyAmount = (amount * copyPercentage) / 100;\r\n            if (copyAmount > maxAmountPerTrade) {\r\n                copyAmount = maxAmountPerTrade;\r\n            }\r\n            \r\n            // Check follower has enough balance (simplified - in production use escrow)\r\n            if (copyAmount < MIN_BET) continue;\r\n            \r\n            // Record copy trade position\r\n            Position storage followerPosition = positions[_marketId][follower];\r\n            if (_position) {\r\n                followerPosition.yesAmount += copyAmount;\r\n                markets[_marketId].totalYesAmount += copyAmount;\r\n            } else {\r\n                followerPosition.noAmount += copyAmount;\r\n                markets[_marketId].totalNoAmount += copyAmount;\r\n            }\r\n            \r\n            // Record in reputation contract\r\n            reputationContract.recordCopyTrade(follower, trader, _marketId, copyAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Resolve a market (only authorized oracles)\r\n     */\r\n    function resolveMarket(uint256 _marketId, bool _outcome) \r\n        external \r\n        nonReentrant \r\n    {\r\n        require(authorizedOracles[msg.sender], \"Not authorized oracle\");\r\n        Market storage market = markets[_marketId];\r\n        require(market.id != 0, \"Market does not exist\");\r\n        require(!market.resolved, \"Market already resolved\");\r\n        require(block.timestamp >= market.endTime, \"Market has not ended\");\r\n\r\n        market.resolved = true;\r\n        market.outcome = _outcome;\r\n        market.resolvedAt = block.timestamp;\r\n\r\n        emit MarketResolved(_marketId, _outcome, block.timestamp);\r\n        \r\n        // Update reputation for all participants\r\n        if (address(reputationContract) != address(0)) {\r\n            _updateParticipantReputation(_marketId, _outcome);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Update reputation for all market participants after resolution\r\n     * @dev Note: In production, process this in batches or off-chain to avoid gas limits\r\n     * @dev For this implementation, reputation updates happen on claim instead\r\n     */\r\n    function _updateParticipantReputation(uint256 /* _marketId */, bool /* outcome */) internal pure {\r\n        // Placeholder - reputation updates happen on claimWinnings instead\r\n        // This prevents hitting gas limits when processing large markets\r\n    }\r\n\r\n    /**\r\n     * @dev Claim winnings from a resolved market\r\n     */\r\n    function claimWinnings(uint256 _marketId) external nonReentrant {\r\n        Market storage market = markets[_marketId];\r\n        require(market.resolved, \"Market not resolved\");\r\n        \r\n        Position storage userPosition = positions[_marketId][msg.sender];\r\n        require(!userPosition.claimed, \"Already claimed\");\r\n        \r\n        uint256 winningAmount = calculateWinnings(_marketId, msg.sender);\r\n        require(winningAmount > 0, \"No winnings to claim\");\r\n        \r\n        userPosition.claimed = true;\r\n        \r\n        // Deduct platform fee\r\n        uint256 fee = (winningAmount * PLATFORM_FEE) / 10000;\r\n        uint256 payout = winningAmount - fee;\r\n        \r\n        // Determine if user won or lost\r\n        bool won = false;\r\n        uint256 userBet = 0;\r\n        if (market.outcome) {\r\n            userBet = userPosition.yesAmount;\r\n            won = userBet > 0;\r\n        } else {\r\n            userBet = userPosition.noAmount;\r\n            won = userBet > 0;\r\n        }\r\n        \r\n        // Update reputation\r\n        if (address(reputationContract) != address(0) && userBet > 0) {\r\n            uint256 profit = won ? (payout > userBet ? payout - userBet : 0) : 0;\r\n            reputationContract.settleBet(msg.sender, _marketId, won, profit);\r\n        }\r\n        \r\n        (bool success, ) = msg.sender.call{value: payout}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit WinningsClaimed(_marketId, msg.sender, payout);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate potential winnings for a user\r\n     */\r\n    function calculateWinnings(uint256 _marketId, address _user) \r\n        public \r\n        view \r\n        returns (uint256) \r\n    {\r\n        Market storage market = markets[_marketId];\r\n        if (!market.resolved) return 0;\r\n        \r\n        Position storage userPosition = positions[_marketId][_user];\r\n        if (userPosition.claimed) return 0;\r\n        \r\n        uint256 userBet;\r\n        uint256 totalWinningBets;\r\n        uint256 totalLosingBets;\r\n        \r\n        if (market.outcome) {\r\n            // YES won\r\n            userBet = userPosition.yesAmount;\r\n            totalWinningBets = market.totalYesAmount;\r\n            totalLosingBets = market.totalNoAmount;\r\n        } else {\r\n            // NO won\r\n            userBet = userPosition.noAmount;\r\n            totalWinningBets = market.totalNoAmount;\r\n            totalLosingBets = market.totalYesAmount;\r\n        }\r\n        \r\n        if (userBet == 0 || totalWinningBets == 0) return 0;\r\n        \r\n        // Calculate proportional share of losing bets\r\n        uint256 share = (userBet * totalLosingBets) / totalWinningBets;\r\n        return userBet + share;\r\n    }\r\n\r\n    /**\r\n     * @dev Get market odds (in percentage)\r\n     */\r\n    function getMarketOdds(uint256 _marketId) \r\n        external \r\n        view \r\n        returns (uint256 yesOdds, uint256 noOdds) \r\n    {\r\n        Market storage market = markets[_marketId];\r\n        uint256 total = market.totalYesAmount + market.totalNoAmount;\r\n        \r\n        if (total == 0) {\r\n            return (5000, 5000); // 50/50 if no bets\r\n        }\r\n        \r\n        yesOdds = (market.totalYesAmount * 10000) / total;\r\n        noOdds = (market.totalNoAmount * 10000) / total;\r\n    }\r\n\r\n    /**\r\n     * @dev Add or remove authorized oracle\r\n     */\r\n    function setAuthorizedOracle(address _oracle, bool _authorized) \r\n        external \r\n        onlyOwner \r\n    {\r\n        authorizedOracles[_oracle] = _authorized;\r\n    }\r\n\r\n    /**\r\n     * @dev Get all market IDs\r\n     */\r\n    function getAllMarkets() external view returns (uint256[] memory) {\r\n        uint256[] memory marketIds = new uint256[](marketCount);\r\n        for (uint256 i = 1; i <= marketCount; i++) {\r\n            marketIds[i - 1] = i;\r\n        }\r\n        return marketIds;\r\n    }\r\n\r\n    /**\r\n     * @dev Get user position in a market\r\n     */\r\n    function getUserPosition(uint256 _marketId, address _user) \r\n        external \r\n        view \r\n        returns (uint256 yesAmount, uint256 noAmount, bool claimed) \r\n    {\r\n        Position storage pos = positions[_marketId][_user];\r\n        return (pos.yesAmount, pos.noAmount, pos.claimed);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw platform fees (only owner)\r\n     */\r\n    function withdrawFees() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        (bool success, ) = owner().call{value: balance}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/TraderReputation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title TraderReputation\r\n * @dev On-chain reputation and copy trading system for PredictBNB\r\n * @notice Tracks trader performance and enables copy trading\r\n */\r\ncontract TraderReputation is ReentrancyGuard, Ownable {\r\n    \r\n    // ============================================================================\r\n    // Structs\r\n    // ============================================================================\r\n    \r\n    struct TraderStats {\r\n        uint256 totalBets;              // Total number of bets placed\r\n        uint256 totalWins;              // Total winning bets\r\n        uint256 totalLosses;            // Total losing bets\r\n        uint256 totalVolume;            // Total amount traded (in wei)\r\n        uint256 totalProfit;            // Total profit earned (in wei)\r\n        uint256 currentStreak;          // Current win/loss streak\r\n        uint256 bestStreak;             // Best win streak ever\r\n        uint256 reputationScore;        // Reputation score (0-1000)\r\n        uint256 lastActivityTime;       // Last time trader was active\r\n        bool isVerified;                // Manual verification status\r\n    }\r\n    \r\n    struct Badge {\r\n        string name;                    // Badge name (e.g., \"Gold Trader\")\r\n        uint256 unlockedAt;             // Timestamp when unlocked\r\n        uint256 tier;                   // Badge tier (1=Bronze, 2=Silver, 3=Gold, 4=Platinum)\r\n    }\r\n    \r\n    struct CopyTrader {\r\n        address trader;                 // Address of trader being copied\r\n        uint256 maxAmountPerTrade;      // Max amount to copy per trade\r\n        uint256 copyPercentage;         // Percentage of trader's bet to copy (1-100)\r\n        bool active;                    // Is copy trading active\r\n        uint256 totalCopied;            // Total amount copied\r\n        uint256 profit;                 // Profit from copying\r\n        uint256 startedAt;              // When started copying\r\n    }\r\n    \r\n    // ============================================================================\r\n    // State Variables\r\n    // ============================================================================\r\n    \r\n    // Trader statistics\r\n    mapping(address => TraderStats) public traderStats;\r\n    \r\n    // Trader badges\r\n    mapping(address => Badge[]) public traderBadges;\r\n    \r\n    // Copy trading: follower => trader => copy settings\r\n    mapping(address => mapping(address => CopyTrader)) public copyTrades;\r\n    \r\n    // Followers list: trader => followers[]\r\n    mapping(address => address[]) public followers;\r\n    mapping(address => uint256) public followerCount;\r\n    \r\n    // Following list: follower => traders[]\r\n    mapping(address => address[]) public following;\r\n    mapping(address => uint256) public followingCount;\r\n    \r\n    // Fees\r\n    uint256 public constant COPY_TRADER_FEE = 500;      // 5% to trader (in basis points)\r\n    uint256 public constant PLATFORM_FEE = 500;         // 5% to platform (in basis points)\r\n    \r\n    // Reputation thresholds for badges\r\n    uint256 public constant BRONZE_THRESHOLD = 100;\r\n    uint256 public constant SILVER_THRESHOLD = 300;\r\n    uint256 public constant GOLD_THRESHOLD = 600;\r\n    uint256 public constant PLATINUM_THRESHOLD = 900;\r\n    \r\n    // ============================================================================\r\n    // Constructor\r\n    // ============================================================================\r\n    \r\n    constructor(address initialOwner) Ownable(initialOwner) {\r\n        // Constructor body (if needed)\r\n    }\r\n    \r\n    // ============================================================================\r\n    // Events\r\n    // ============================================================================\r\n    \r\n    event BetPlaced(\r\n        address indexed trader,\r\n        uint256 indexed marketId,\r\n        uint256 amount,\r\n        bool position\r\n    );\r\n    \r\n    event BetSettled(\r\n        address indexed trader,\r\n        uint256 indexed marketId,\r\n        bool won,\r\n        uint256 profit\r\n    );\r\n    \r\n    event ReputationUpdated(\r\n        address indexed trader,\r\n        uint256 newScore,\r\n        uint256 oldScore\r\n    );\r\n    \r\n    event BadgeUnlocked(\r\n        address indexed trader,\r\n        string badgeName,\r\n        uint256 tier\r\n    );\r\n    \r\n    event TraderFollowed(\r\n        address indexed follower,\r\n        address indexed trader,\r\n        uint256 maxAmountPerTrade,\r\n        uint256 copyPercentage\r\n    );\r\n    \r\n    event TraderUnfollowed(\r\n        address indexed follower,\r\n        address indexed trader\r\n    );\r\n    \r\n    event TradeCopied(\r\n        address indexed follower,\r\n        address indexed trader,\r\n        uint256 indexed marketId,\r\n        uint256 amount\r\n    );\r\n    \r\n    event CopyTradeSettled(\r\n        address indexed follower,\r\n        address indexed trader,\r\n        uint256 profit,\r\n        uint256 traderFee,\r\n        uint256 platformFee\r\n    );\r\n    \r\n    // ============================================================================\r\n    // Main Functions\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @notice Record a bet placement (called by PredictionMarket contract)\r\n     * @param trader Address of the trader\r\n     * @param marketId Market ID\r\n     * @param amount Bet amount\r\n     * @param position True for YES, False for NO\r\n     */\r\n    function recordBet(\r\n        address trader,\r\n        uint256 marketId,\r\n        uint256 amount,\r\n        bool position\r\n    ) external {\r\n        TraderStats storage stats = traderStats[trader];\r\n        uint256 oldScore = stats.reputationScore;\r\n        \r\n        stats.totalBets++;\r\n        stats.totalVolume += amount;\r\n        stats.lastActivityTime = block.timestamp;\r\n        \r\n        // Initialize reputation if first bet, otherwise add points for participation\r\n        if (stats.totalBets == 1) {\r\n            stats.reputationScore = 100; // Starting score\r\n        } else {\r\n            // Award 10 reputation points for each bet placed\r\n            stats.reputationScore += 10;\r\n            // Cap at 1000\r\n            if (stats.reputationScore > 1000) {\r\n                stats.reputationScore = 1000;\r\n            }\r\n        }\r\n        \r\n        emit BetPlaced(trader, marketId, amount, position);\r\n        if (stats.reputationScore != oldScore) {\r\n            emit ReputationUpdated(trader, stats.reputationScore, oldScore);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Record bet settlement (win/loss)\r\n     * @param trader Address of the trader\r\n     * @param marketId Market ID\r\n     * @param won True if won, false if lost\r\n     * @param profit Profit amount (0 if lost)\r\n     */\r\n    function settleBet(\r\n        address trader,\r\n        uint256 marketId,\r\n        bool won,\r\n        uint256 profit\r\n    ) external {\r\n        TraderStats storage stats = traderStats[trader];\r\n        uint256 oldScore = stats.reputationScore;\r\n        \r\n        if (won) {\r\n            stats.totalWins++;\r\n            stats.totalProfit += profit;\r\n            stats.currentStreak++;\r\n            \r\n            // Award additional 20 reputation points for winning\r\n            stats.reputationScore += 20;\r\n            // Cap at 1000\r\n            if (stats.reputationScore > 1000) {\r\n                stats.reputationScore = 1000;\r\n            }\r\n            \r\n            // Update best streak\r\n            if (stats.currentStreak > stats.bestStreak) {\r\n                stats.bestStreak = stats.currentStreak;\r\n            }\r\n        } else {\r\n            stats.totalLosses++;\r\n            stats.currentStreak = 0; // Reset streak on loss\r\n        }\r\n        \r\n        emit ReputationUpdated(trader, stats.reputationScore, oldScore);\r\n        emit BetSettled(trader, marketId, won, profit);\r\n        \r\n        // Check and award badges\r\n        _checkAndAwardBadges(trader);\r\n    }\r\n    \r\n    /**\r\n     * @notice Calculate reputation score based on performance\r\n     * @param trader Address of the trader\r\n     * @return Reputation score (0-1000)\r\n     */\r\n    function calculateReputationScore(address trader) public view returns (uint256) {\r\n        TraderStats memory stats = traderStats[trader];\r\n        \r\n        if (stats.totalBets == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        // Win rate component (0-400 points)\r\n        uint256 winRate = (stats.totalWins * 10000) / stats.totalBets; // 0-10000 (0-100%)\r\n        uint256 winRateScore = (winRate * 400) / 10000;\r\n        \r\n        // Volume component (0-300 points)\r\n        uint256 volumeScore = 0;\r\n        if (stats.totalVolume >= 100 ether) {\r\n            volumeScore = 300;\r\n        } else if (stats.totalVolume >= 50 ether) {\r\n            volumeScore = 250;\r\n        } else if (stats.totalVolume >= 10 ether) {\r\n            volumeScore = 200;\r\n        } else if (stats.totalVolume >= 1 ether) {\r\n            volumeScore = 100;\r\n        } else {\r\n            volumeScore = (stats.totalVolume * 100) / 1 ether;\r\n        }\r\n        \r\n        // Activity component (0-150 points)\r\n        uint256 activityScore = 0;\r\n        if (stats.totalBets >= 100) {\r\n            activityScore = 150;\r\n        } else if (stats.totalBets >= 50) {\r\n            activityScore = 100;\r\n        } else if (stats.totalBets >= 10) {\r\n            activityScore = 50;\r\n        } else {\r\n            activityScore = (stats.totalBets * 5);\r\n        }\r\n        \r\n        // Streak component (0-150 points)\r\n        uint256 streakScore = 0;\r\n        if (stats.bestStreak >= 20) {\r\n            streakScore = 150;\r\n        } else if (stats.bestStreak >= 10) {\r\n            streakScore = 100;\r\n        } else if (stats.bestStreak >= 5) {\r\n            streakScore = 50;\r\n        } else {\r\n            streakScore = stats.bestStreak * 10;\r\n        }\r\n        \r\n        uint256 totalScore = winRateScore + volumeScore + activityScore + streakScore;\r\n        \r\n        // Cap at 1000\r\n        return totalScore > 1000 ? 1000 : totalScore;\r\n    }\r\n    \r\n    /**\r\n     * @notice Check and award badges based on reputation\r\n     */\r\n    function _checkAndAwardBadges(address trader) internal {\r\n        TraderStats memory stats = traderStats[trader];\r\n        Badge[] storage badges = traderBadges[trader];\r\n        \r\n        // Check for Platinum (top tier)\r\n        if (stats.reputationScore >= PLATINUM_THRESHOLD && !_hasBadgeTier(trader, 4)) {\r\n            badges.push(Badge(\"Platinum Trader\", block.timestamp, 4));\r\n            emit BadgeUnlocked(trader, \"Platinum Trader\", 4);\r\n        }\r\n        // Check for Gold\r\n        else if (stats.reputationScore >= GOLD_THRESHOLD && !_hasBadgeTier(trader, 3)) {\r\n            badges.push(Badge(\"Gold Trader\", block.timestamp, 3));\r\n            emit BadgeUnlocked(trader, \"Gold Trader\", 3);\r\n        }\r\n        // Check for Silver\r\n        else if (stats.reputationScore >= SILVER_THRESHOLD && !_hasBadgeTier(trader, 2)) {\r\n            badges.push(Badge(\"Silver Trader\", block.timestamp, 2));\r\n            emit BadgeUnlocked(trader, \"Silver Trader\", 2);\r\n        }\r\n        // Check for Bronze\r\n        else if (stats.reputationScore >= BRONZE_THRESHOLD && !_hasBadgeTier(trader, 1)) {\r\n            badges.push(Badge(\"Bronze Trader\", block.timestamp, 1));\r\n            emit BadgeUnlocked(trader, \"Bronze Trader\", 1);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Check if trader has a badge of specific tier\r\n     */\r\n    function _hasBadgeTier(address trader, uint256 tier) internal view returns (bool) {\r\n        Badge[] memory badges = traderBadges[trader];\r\n        for (uint256 i = 0; i < badges.length; i++) {\r\n            if (badges[i].tier == tier) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    // ============================================================================\r\n    // Copy Trading Functions\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @notice Follow a trader and enable copy trading\r\n     * @param trader Address of trader to follow\r\n     * @param maxAmountPerTrade Maximum amount to copy per trade\r\n     * @param copyPercentage Percentage of trader's bet to copy (1-100)\r\n     */\r\n    function followTrader(\r\n        address trader,\r\n        uint256 maxAmountPerTrade,\r\n        uint256 copyPercentage\r\n    ) external {\r\n        require(trader != msg.sender, \"Cannot follow yourself\");\r\n        require(copyPercentage > 0 && copyPercentage <= 100, \"Invalid percentage\");\r\n        require(maxAmountPerTrade > 0, \"Invalid max amount\");\r\n        require(!copyTrades[msg.sender][trader].active, \"Already following\");\r\n        \r\n        // Create copy trade settings\r\n        copyTrades[msg.sender][trader] = CopyTrader({\r\n            trader: trader,\r\n            maxAmountPerTrade: maxAmountPerTrade,\r\n            copyPercentage: copyPercentage,\r\n            active: true,\r\n            totalCopied: 0,\r\n            profit: 0,\r\n            startedAt: block.timestamp\r\n        });\r\n        \r\n        // Update followers list\r\n        followers[trader].push(msg.sender);\r\n        followerCount[trader]++;\r\n        \r\n        // Update following list\r\n        following[msg.sender].push(trader);\r\n        followingCount[msg.sender]++;\r\n        \r\n        emit TraderFollowed(msg.sender, trader, maxAmountPerTrade, copyPercentage);\r\n    }\r\n    \r\n    /**\r\n     * @notice Unfollow a trader\r\n     * @param trader Address of trader to unfollow\r\n     */\r\n    function unfollowTrader(address trader) external {\r\n        require(copyTrades[msg.sender][trader].active, \"Not following\");\r\n        \r\n        // Deactivate copy trading\r\n        copyTrades[msg.sender][trader].active = false;\r\n        \r\n        // Remove from followers list (gas intensive, consider keeping inactive)\r\n        followerCount[trader]--;\r\n        followingCount[msg.sender]--;\r\n        \r\n        emit TraderUnfollowed(msg.sender, trader);\r\n    }\r\n    \r\n    /**\r\n     * @notice Update copy trading settings\r\n     * @param trader Address of trader\r\n     * @param maxAmountPerTrade New max amount\r\n     * @param copyPercentage New copy percentage\r\n     */\r\n    function updateCopySettings(\r\n        address trader,\r\n        uint256 maxAmountPerTrade,\r\n        uint256 copyPercentage\r\n    ) external {\r\n        require(copyTrades[msg.sender][trader].active, \"Not following\");\r\n        require(copyPercentage > 0 && copyPercentage <= 100, \"Invalid percentage\");\r\n        \r\n        CopyTrader storage copyTrade = copyTrades[msg.sender][trader];\r\n        copyTrade.maxAmountPerTrade = maxAmountPerTrade;\r\n        copyTrade.copyPercentage = copyPercentage;\r\n    }\r\n    \r\n    /**\r\n     * @notice Record a copied trade\r\n     * @param follower Address of follower\r\n     * @param trader Address of trader being copied\r\n     * @param marketId Market ID\r\n     * @param amount Amount copied\r\n     */\r\n    function recordCopyTrade(\r\n        address follower,\r\n        address trader,\r\n        uint256 marketId,\r\n        uint256 amount\r\n    ) external {\r\n        require(copyTrades[follower][trader].active, \"Copy trading not active\");\r\n        \r\n        CopyTrader storage copyTrade = copyTrades[follower][trader];\r\n        copyTrade.totalCopied += amount;\r\n        \r\n        emit TradeCopied(follower, trader, marketId, amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Settle a copy trade (distribute fees)\r\n     * @param follower Address of follower\r\n     * @param trader Address of trader\r\n     * @param profit Profit amount\r\n     */\r\n    function settleCopyTrade(\r\n        address follower,\r\n        address trader,\r\n        uint256 profit\r\n    ) external payable {\r\n        require(copyTrades[follower][trader].active, \"Copy trading not active\");\r\n        \r\n        if (profit > 0) {\r\n            // Calculate fees\r\n            uint256 traderFee = (profit * COPY_TRADER_FEE) / 10000;\r\n            uint256 platformFee = (profit * PLATFORM_FEE) / 10000;\r\n            uint256 followerProfit = profit - traderFee - platformFee;\r\n            \r\n            // Update copy trade stats\r\n            CopyTrader storage copyTrade = copyTrades[follower][trader];\r\n            copyTrade.profit += followerProfit;\r\n            \r\n            // Transfer fees\r\n            payable(trader).transfer(traderFee);\r\n            payable(owner()).transfer(platformFee);\r\n            payable(follower).transfer(followerProfit);\r\n            \r\n            emit CopyTradeSettled(follower, trader, followerProfit, traderFee, platformFee);\r\n        }\r\n    }\r\n    \r\n    // ============================================================================\r\n    // View Functions\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @notice Get trader statistics\r\n     */\r\n    function getTraderStats(address trader) external view returns (\r\n        uint256 totalBets,\r\n        uint256 totalWins,\r\n        uint256 totalLosses,\r\n        uint256 totalVolume,\r\n        uint256 totalProfit,\r\n        uint256 winRate,\r\n        uint256 currentStreak,\r\n        uint256 bestStreak,\r\n        uint256 reputationScore\r\n    ) {\r\n        TraderStats memory stats = traderStats[trader];\r\n        uint256 _winRate = stats.totalBets > 0 ? (stats.totalWins * 100) / stats.totalBets : 0;\r\n        \r\n        return (\r\n            stats.totalBets,\r\n            stats.totalWins,\r\n            stats.totalLosses,\r\n            stats.totalVolume,\r\n            stats.totalProfit,\r\n            _winRate,\r\n            stats.currentStreak,\r\n            stats.bestStreak,\r\n            stats.reputationScore\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Get trader follower count\r\n     */\r\n    function getTraderFollowerCount(address trader) external view returns (uint256) {\r\n        return followerCount[trader];\r\n    }\r\n    \r\n    /**\r\n     * @notice Get trader badges\r\n     */\r\n    function getTraderBadges(address trader) external view returns (Badge[] memory) {\r\n        return traderBadges[trader];\r\n    }\r\n    \r\n    /**\r\n     * @notice Get copy trade settings\r\n     */\r\n    function getCopyTradeSettings(address follower, address trader) external view returns (\r\n        uint256 maxAmountPerTrade,\r\n        uint256 copyPercentage,\r\n        bool active,\r\n        uint256 totalCopied,\r\n        uint256 profit\r\n    ) {\r\n        CopyTrader memory copyTrade = copyTrades[follower][trader];\r\n        return (\r\n            copyTrade.maxAmountPerTrade,\r\n            copyTrade.copyPercentage,\r\n            copyTrade.active,\r\n            copyTrade.totalCopied,\r\n            copyTrade.profit\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Get list of followers\r\n     */\r\n    function getFollowers(address trader) external view returns (address[] memory) {\r\n        return followers[trader];\r\n    }\r\n    \r\n    /**\r\n     * @notice Get list of traders being followed\r\n     */\r\n    function getFollowing(address follower) external view returns (address[] memory) {\r\n        return following[follower];\r\n    }\r\n    \r\n    /**\r\n     * @notice Get current badge tier\r\n     */\r\n    function getCurrentBadgeTier(address trader) external view returns (uint256) {\r\n        Badge[] memory badges = traderBadges[trader];\r\n        uint256 highestTier = 0;\r\n        \r\n        for (uint256 i = 0; i < badges.length; i++) {\r\n            if (badges[i].tier > highestTier) {\r\n                highestTier = badges[i].tier;\r\n            }\r\n        }\r\n        \r\n        return highestTier;\r\n    }\r\n    \r\n    // ============================================================================\r\n    // Admin Functions\r\n    // ============================================================================\r\n    \r\n    /**\r\n     * @notice Get trader reputation score\r\n     */\r\n    function getReputationScore(address trader) external view returns (uint256) {\r\n        return traderStats[trader].reputationScore;\r\n    }\r\n    \r\n    /**\r\n     * @notice Manually verify a trader\r\n     */\r\n    function verifyTrader(address trader) external onlyOwner {\r\n        traderStats[trader].isVerified = true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Remove verification\r\n     */\r\n    function unverifyTrader(address trader) external onlyOwner {\r\n        traderStats[trader].isVerified = false;\r\n    }\r\n}\r\n"
    },
    "contracts/WBNB3009.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title WBNB3009\r\n * @dev Wrapped BNB with EIP-3009 transferWithAuthorization for x402 gasless transactions\r\n * @notice This allows users to interact with BNB in a gasless way!\r\n * \r\n * How it works:\r\n * 1. User wraps BNB → gets WBNB3009 tokens\r\n * 2. User signs EIP-3009 authorization (off-chain, FREE)\r\n * 3. Facilitator executes authorization (pays gas)\r\n * 4. WBNB3009 transferred to contract\r\n * 5. Contract unwraps to native BNB\r\n * 6. BNB used for betting\r\n * \r\n * Result: User only needs BNB once (to wrap), then ALL future transactions are gasless!\r\n */\r\ncontract WBNB3009 is ERC20, ReentrancyGuard {\r\n    \r\n    // EIP-712 Domain\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    \r\n    // EIP-3009 typehashes\r\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = \r\n        keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\r\n    \r\n    bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\r\n        keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\r\n    \r\n    // Nonce tracking for replay protection\r\n    mapping(address => mapping(bytes32 => bool)) public authorizationState;\r\n    \r\n    // Events\r\n    event Deposit(address indexed account, uint256 amount);\r\n    event Withdrawal(address indexed account, uint256 amount);\r\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\r\n    \r\n    constructor() ERC20(\"Wrapped BNB with x402\", \"WBNB3009\") {\r\n        // Create EIP-712 domain separator\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(\"Wrapped BNB with x402\")),\r\n                keccak256(bytes(\"1\")),\r\n                block.chainid,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Wrap BNB to WBNB3009 (1:1)\r\n     */\r\n    function deposit() external payable {\r\n        _mint(msg.sender, msg.value);\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev Unwrap WBNB3009 back to BNB (1:1)\r\n     */\r\n    function withdraw(uint256 amount) external nonReentrant {\r\n        _burn(msg.sender, amount);\r\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\r\n        require(success, \"BNB transfer failed\");\r\n        emit Withdrawal(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Allow contract to receive BNB for wrapping\r\n     */\r\n    receive() external payable {\r\n        _mint(msg.sender, msg.value);\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev EIP-3009 transferWithAuthorization\r\n     * @notice This is the KEY function for gasless x402 transactions!\r\n     * User signs this off-chain, facilitator executes and pays gas\r\n     */\r\n    function transferWithAuthorization(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        // Check time validity\r\n        require(block.timestamp >= validAfter, \"Authorization not yet valid\");\r\n        require(block.timestamp <= validBefore, \"Authorization expired\");\r\n        \r\n        // Check nonce not used (replay protection)\r\n        require(!authorizationState[from][nonce], \"Authorization already used\");\r\n        \r\n        // Verify EIP-712 signature\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\r\n                        from,\r\n                        to,\r\n                        value,\r\n                        validAfter,\r\n                        validBefore,\r\n                        nonce\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        \r\n        address signer = _recoverSigner(digest, signature);\r\n        require(signer == from, \"Invalid signature\");\r\n        \r\n        // Mark nonce as used\r\n        authorizationState[from][nonce] = true;\r\n        emit AuthorizationUsed(from, nonce);\r\n        \r\n        // Execute transfer\r\n        _transfer(from, to, value);\r\n    }\r\n    \r\n    /**\r\n     * @dev EIP-3009 receiveWithAuthorization\r\n     * @notice Safer version that ensures msg.sender is the recipient\r\n     * Prevents front-running attacks\r\n     */\r\n    function receiveWithAuthorization(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        // IMPORTANT: msg.sender must be the recipient (prevents front-running)\r\n        require(to == msg.sender, \"Caller must be the payee\");\r\n        \r\n        // Check time validity\r\n        require(block.timestamp >= validAfter, \"Authorization not yet valid\");\r\n        require(block.timestamp <= validBefore, \"Authorization expired\");\r\n        \r\n        // Check nonce not used\r\n        require(!authorizationState[from][nonce], \"Authorization already used\");\r\n        \r\n        // Verify EIP-712 signature\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        RECEIVE_WITH_AUTHORIZATION_TYPEHASH,\r\n                        from,\r\n                        to,\r\n                        value,\r\n                        validAfter,\r\n                        validBefore,\r\n                        nonce\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        \r\n        address signer = _recoverSigner(digest, signature);\r\n        require(signer == from, \"Invalid signature\");\r\n        \r\n        // Mark nonce as used\r\n        authorizationState[from][nonce] = true;\r\n        emit AuthorizationUsed(from, nonce);\r\n        \r\n        // Execute transfer\r\n        _transfer(from, to, value);\r\n    }\r\n    \r\n    /**\r\n     * @dev Recover signer from signature\r\n     */\r\n    function _recoverSigner(bytes32 digest, bytes memory signature) \r\n        internal \r\n        pure \r\n        returns (address) \r\n    {\r\n        require(signature.length == 65, \"Invalid signature length\");\r\n        \r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        \r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n        \r\n        // Adjust v if needed\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        \r\n        require(v == 27 || v == 28, \"Invalid signature v value\");\r\n        \r\n        address signer = ecrecover(digest, v, r, s);\r\n        require(signer != address(0), \"Invalid signature\");\r\n        \r\n        return signer;\r\n    }\r\n}\r\n"
    },
    "contracts/X402Betting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./PredictionMarket.sol\";\r\n\r\n/**\r\n * @title X402Betting\r\n * @dev Implements x402 protocol for gasless betting via EIP-3009 transferWithAuthorization\r\n * @notice Enables truly gasless betting - users sign payment authorization, facilitator executes\r\n * @notice This contract handles ERC20 token payments and converts to BNB for PredictionMarket\r\n */\r\ninterface IERC20TransferWithAuth is IERC20 {\r\n    function transferWithAuthorization(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external;\r\n}\r\n\r\ncontract X402Betting is ReentrancyGuard, Ownable {\r\n    PredictionMarket public predictionMarket;\r\n    IERC20TransferWithAuth public bettingToken;\r\n    \r\n    // x402 payment tracking\r\n    mapping(bytes32 => bool) public usedNonces;\r\n    mapping(address => uint256) public gasAllowances; // Sponsored gas per user\r\n    \r\n    // Facilitator settings\r\n    uint256 public facilitatorFee = 50; // 0.5% fee for gas sponsorship\r\n    address public facilitator;\r\n    \r\n    // Token to BNB conversion (simplified - in production use DEX oracle)\r\n    uint256 public tokenToBnbRate = 1e18; // 1 token = 1 BNB (1:1 rate for testing)\r\n    \r\n    event GaslessPositionTaken(\r\n        uint256 indexed marketId,\r\n        address indexed user,\r\n        bool position,\r\n        uint256 amount,\r\n        bytes32 nonce\r\n    );\r\n    \r\n    event GasSponsored(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 newAllowance\r\n    );\r\n    \r\n    constructor(\r\n        address _predictionMarket,\r\n        address _bettingToken\r\n    ) Ownable(msg.sender) {\r\n        predictionMarket = PredictionMarket(payable(_predictionMarket));\r\n        bettingToken = IERC20TransferWithAuth(_bettingToken);\r\n        facilitator = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * @dev Place bet using x402 protocol (EIP-3009 transferWithAuthorization)\r\n     * @notice Gasless betting - user signs authorization, facilitator executes\r\n     */\r\n    function buyPositionWithAuthorization(\r\n        uint256 marketId,\r\n        bool position,\r\n        address from,\r\n        uint256 value,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        // Verify caller is facilitator (gas sponsor)\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator can execute\");\r\n        \r\n        // Check nonce not used (replay protection)\r\n        require(!usedNonces[nonce], \"Authorization already used\");\r\n        usedNonces[nonce] = true;\r\n        \r\n        // Check time validity\r\n        require(block.timestamp >= validAfter, \"Authorization not yet valid\");\r\n        require(block.timestamp <= validBefore, \"Authorization expired\");\r\n        \r\n        // Calculate amounts\r\n        uint256 feeAmount = (value * facilitatorFee) / 10000;\r\n        uint256 betTokenAmount = value - feeAmount;\r\n        \r\n        // Execute EIP-3009 transfer from user to this contract\r\n        bettingToken.transferWithAuthorization(\r\n            from,\r\n            address(this),\r\n            value,\r\n            validAfter,\r\n            validBefore,\r\n            nonce,\r\n            signature\r\n        );\r\n        \r\n        // Convert token amount to BNB equivalent for PredictionMarket\r\n        // Note: Uses tokenToBnbRate conversion (1:1 for simplicity in testnet)\r\n        uint256 betBnbAmount = (betTokenAmount * tokenToBnbRate) / 1e18;\r\n        \r\n        // Ensure contract has enough BNB to cover the bet\r\n        // Facilitator must keep this contract funded with BNB\r\n        require(address(this).balance >= betBnbAmount, \"Insufficient BNB balance\");\r\n        \r\n        // Place bet in PredictionMarket using BNB\r\n        predictionMarket.buyPositionForUser{value: betBnbAmount}(marketId, position, from);\r\n        \r\n        // Track gas sponsorship\r\n        uint256 gasUsed = tx.gasprice * gasleft();\r\n        gasAllowances[from] += gasUsed;\r\n        \r\n        emit GaslessPositionTaken(marketId, from, position, betBnbAmount, nonce);\r\n        emit GasSponsored(from, gasUsed, gasAllowances[from]);\r\n    }\r\n    \r\n    /**\r\n     * @dev Verify payment authorization (for x402 /verify endpoint)\r\n     * @notice Off-chain verification before settlement\r\n     */\r\n    function verifyAuthorization(\r\n        address from,\r\n        uint256 value,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        bytes memory /* signature */\r\n    ) external view returns (bool valid, string memory reason) {\r\n        // Check nonce\r\n        if (usedNonces[nonce]) {\r\n            return (false, \"nonce_already_used\");\r\n        }\r\n        \r\n        // Check time window\r\n        if (block.timestamp < validAfter) {\r\n            return (false, \"authorization_not_yet_valid\");\r\n        }\r\n        if (block.timestamp > validBefore) {\r\n            return (false, \"authorization_expired\");\r\n        }\r\n        \r\n        // Check balance\r\n        if (bettingToken.balanceOf(from) < value) {\r\n            return (false, \"insufficient_balance\");\r\n        }\r\n        \r\n        // All checks passed\r\n        return (true, \"\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Set facilitator address (gas sponsor)\r\n     */\r\n    function setFacilitator(address _facilitator) external onlyOwner {\r\n        facilitator = _facilitator;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set facilitator fee (basis points)\r\n     */\r\n    function setFacilitatorFee(uint256 _fee) external onlyOwner {\r\n        require(_fee <= 500, \"Fee too high\"); // Max 5%\r\n        facilitatorFee = _fee;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set token to BNB conversion rate\r\n     * @param _rate Rate in wei (1e18 = 1:1 ratio)\r\n     */\r\n    function setTokenToBnbRate(uint256 _rate) external onlyOwner {\r\n        require(_rate > 0, \"Rate must be positive\");\r\n        tokenToBnbRate = _rate;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set betting token contract\r\n     */\r\n    function setBettingToken(address _token) external onlyOwner {\r\n        bettingToken = IERC20TransferWithAuth(_token);\r\n    }\r\n    \r\n    /**\r\n     * @dev Withdraw collected token fees\r\n     */\r\n    function withdrawTokenFees() external onlyOwner {\r\n        uint256 tokenBalance = bettingToken.balanceOf(address(this));\r\n        require(tokenBalance > 0, \"No token fees to withdraw\");\r\n        require(bettingToken.transfer(owner(), tokenBalance), \"Transfer failed\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Withdraw BNB (in case of overfunding)\r\n     */\r\n    function withdrawBnb() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No BNB to withdraw\");\r\n        payable(owner()).transfer(balance);\r\n    }\r\n    \r\n    /**\r\n     * @dev Claim winnings gaslessly (EIP-712 signature)\r\n     * @notice User signs claim authorization, facilitator executes and pays gas\r\n     */\r\n    function claimWinningsWithAuthorization(\r\n        uint256 marketId,\r\n        address from,\r\n        uint256 deadline,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator\");\r\n        require(!usedNonces[nonce], \"Nonce already used\");\r\n        require(block.timestamp <= deadline, \"Authorization expired\");\r\n        \r\n        usedNonces[nonce] = true;\r\n        \r\n        // Verify EIP-712 signature\r\n        bytes32 messageHash = keccak256(abi.encode(\r\n            keccak256(\"ClaimWinnings(uint256 marketId,address from,uint256 deadline,bytes32 nonce)\"),\r\n            marketId,\r\n            from,\r\n            deadline,\r\n            nonce\r\n        ));\r\n        \r\n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\r\n        address signer = recoverSigner(ethSignedHash, signature);\r\n        require(signer == from, \"Invalid signature\");\r\n        \r\n        // Execute claim (msg.sender is facilitator, but claim is for 'from' address)\r\n        // Note: PredictionMarket needs to be modified to accept claimFor(user)\r\n        // For now, we'll send BNB back to user after claiming\r\n        uint256 balanceBefore = address(this).balance;\r\n        \r\n        // Since we can't directly claim for user, user must call this themselves\r\n        // This is a limitation - we'll add claimFor() to PredictionMarket in next deployment\r\n        // For now, deduct facilitator fee from winnings and forward\r\n        \r\n        uint256 winnings = predictionMarket.calculateWinnings(marketId, from);\r\n        require(winnings > 0, \"No winnings to claim\");\r\n        \r\n        uint256 feeAmount = (winnings * facilitatorFee) / 10000;\r\n        uint256 payout = winnings - feeAmount;\r\n        \r\n        // Track gas sponsorship\r\n        uint256 gasUsed = tx.gasprice * gasleft();\r\n        gasAllowances[from] += gasUsed;\r\n        \r\n        emit GasSponsored(from, gasUsed, gasAllowances[from]);\r\n        \r\n        // Note: Actual claim needs PredictionMarket.claimFor() function\r\n        // This is a placeholder for the pattern\r\n    }\r\n    \r\n    /**\r\n     * @dev Follow trader gaslessly (EIP-712 signature)\r\n     */\r\n    function followTraderWithAuthorization(\r\n        address trader,\r\n        uint256 maxAmountPerTrade,\r\n        uint256 copyPercentage,\r\n        address from,\r\n        uint256 deadline,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator\");\r\n        require(!usedNonces[nonce], \"Nonce already used\");\r\n        require(block.timestamp <= deadline, \"Authorization expired\");\r\n        \r\n        usedNonces[nonce] = true;\r\n        \r\n        // Verify signature\r\n        bytes32 messageHash = keccak256(abi.encode(\r\n            keccak256(\"FollowTrader(address trader,uint256 maxAmountPerTrade,uint256 copyPercentage,address from,uint256 deadline,bytes32 nonce)\"),\r\n            trader,\r\n            maxAmountPerTrade,\r\n            copyPercentage,\r\n            from,\r\n            deadline,\r\n            nonce\r\n        ));\r\n        \r\n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\r\n        address signer = recoverSigner(ethSignedHash, signature);\r\n        require(signer == from, \"Invalid signature\");\r\n        \r\n        // Track gas sponsorship\r\n        uint256 gasUsed = tx.gasprice * gasleft();\r\n        gasAllowances[from] += gasUsed;\r\n        \r\n        emit GasSponsored(from, gasUsed, gasAllowances[from]);\r\n        \r\n        // Note: Needs TraderReputation.followFor() function\r\n    }\r\n    \r\n    /**\r\n     * @dev Unfollow trader gaslessly\r\n     */\r\n    function unfollowTraderWithAuthorization(\r\n        address trader,\r\n        address from,\r\n        uint256 deadline,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator\");\r\n        require(!usedNonces[nonce], \"Nonce already used\");\r\n        require(block.timestamp <= deadline, \"Authorization expired\");\r\n        \r\n        usedNonces[nonce] = true;\r\n        \r\n        // Verify signature\r\n        bytes32 messageHash = keccak256(abi.encode(\r\n            keccak256(\"UnfollowTrader(address trader,address from,uint256 deadline,bytes32 nonce)\"),\r\n            trader,\r\n            from,\r\n            deadline,\r\n            nonce\r\n        ));\r\n        \r\n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\r\n        address signer = recoverSigner(ethSignedHash, signature);\r\n        require(signer == from, \"Invalid signature\");\r\n        \r\n        // Track gas sponsorship\r\n        uint256 gasUsed = tx.gasprice * gasleft();\r\n        gasAllowances[from] += gasUsed;\r\n        \r\n        emit GasSponsored(from, gasUsed, gasAllowances[from]);\r\n        \r\n        // Note: Needs TraderReputation.unfollowFor() function\r\n    }\r\n    \r\n    /**\r\n     * @dev Create market gaslessly (EIP-712 signature)\r\n     */\r\n    function createMarketWithAuthorization(\r\n        string memory question,\r\n        string memory description,\r\n        string memory category,\r\n        uint256 endTime,\r\n        bool aiOracleEnabled,\r\n        address from,\r\n        uint256 deadline,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator\");\r\n        require(!usedNonces[nonce], \"Nonce already used\");\r\n        require(block.timestamp <= deadline, \"Authorization expired\");\r\n        \r\n        usedNonces[nonce] = true;\r\n        \r\n        // Verify signature\r\n        bytes32 messageHash = keccak256(abi.encode(\r\n            keccak256(\"CreateMarket(string question,string description,string category,uint256 endTime,bool aiOracleEnabled,address from,uint256 deadline,bytes32 nonce)\"),\r\n            keccak256(bytes(question)),\r\n            keccak256(bytes(description)),\r\n            keccak256(bytes(category)),\r\n            endTime,\r\n            aiOracleEnabled,\r\n            from,\r\n            deadline,\r\n            nonce\r\n        ));\r\n        \r\n        bytes32 ethSignedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\r\n        address signer = recoverSigner(ethSignedHash, signature);\r\n        require(signer == from, \"Invalid signature\");\r\n        \r\n        // Track gas sponsorship\r\n        uint256 gasUsed = tx.gasprice * gasleft();\r\n        gasAllowances[from] += gasUsed;\r\n        \r\n        emit GasSponsored(from, gasUsed, gasAllowances[from]);\r\n        \r\n        // Note: Needs PredictionMarket.createMarketFor() function\r\n    }\r\n    \r\n    /**\r\n     * @dev Recover signer from signature\r\n     */\r\n    function recoverSigner(bytes32 ethSignedHash, bytes memory signature) internal pure returns (address) {\r\n        require(signature.length == 65, \"Invalid signature length\");\r\n        \r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        \r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n        \r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        \r\n        require(v == 27 || v == 28, \"Invalid signature 'v' value\");\r\n        \r\n        return ecrecover(ethSignedHash, v, r, s);\r\n    }\r\n    \r\n    /**\r\n     * @dev Receive BNB to fund gasless operations\r\n     * @notice Facilitator funds this contract with BNB for bet execution\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/X402BettingBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./PredictionMarket.sol\";\r\nimport \"./WBNB3009.sol\";\r\n\r\n/**\r\n * @title X402BettingBNB\r\n * @dev x402 protocol for 100% GASLESS BNB betting\r\n * @notice Users only need BNB, NO separate USDC needed!\r\n * \r\n * REVOLUTIONARY APPROACH:\r\n * 1. User wraps BNB → WBNB3009 (one-time, pays gas once)\r\n * 2. User signs WBNB3009 authorization (EIP-3009, off-chain, FREE)\r\n * 3. Facilitator executes (pays gas)\r\n * 4. WBNB3009 auto-unwraps to BNB\r\n * 5. BNB used for betting\r\n * \r\n * RESULT: After initial wrap, ALL bets are 100% GASLESS!\r\n */\r\ncontract X402BettingBNB is ReentrancyGuard, Ownable {\r\n    \r\n    PredictionMarket public predictionMarket;\r\n    WBNB3009 public wbnb;\r\n    \r\n    // x402 payment tracking\r\n    mapping(bytes32 => bool) public usedNonces;\r\n    mapping(address => uint256) public gasCredits; // Sponsored gas tracking\r\n    \r\n    // Facilitator settings\r\n    uint256 public facilitatorFee = 50; // 0.5% (50 basis points)\r\n    address public facilitator;\r\n    \r\n    event GaslessBetPlaced(\r\n        uint256 indexed marketId,\r\n        address indexed user,\r\n        bool position,\r\n        uint256 bnbAmount,\r\n        bytes32 nonce\r\n    );\r\n    \r\n    event GasSponsored(\r\n        address indexed user,\r\n        uint256 gasUsed\r\n    );\r\n    \r\n    event WBNBWrapped(\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n    \r\n    constructor(\r\n        address _predictionMarket,\r\n        address _wbnb\r\n    ) Ownable(msg.sender) {\r\n        predictionMarket = PredictionMarket(payable(_predictionMarket));\r\n        wbnb = WBNB3009(payable(_wbnb));\r\n        facilitator = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * @dev Helper: Wrap BNB to WBNB3009\r\n     * @notice Users can call this directly on WBNB contract or use this helper\r\n     */\r\n    function wrapBNB() external payable {\r\n        wbnb.deposit{value: msg.value}();\r\n        require(wbnb.transfer(msg.sender, msg.value), \"Transfer failed\");\r\n        emit WBNBWrapped(msg.sender, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev GASLESS BETTING with pure BNB!\r\n     * @notice User signs WBNB3009 authorization, facilitator executes\r\n     * \r\n     * Flow:\r\n     * 1. User has WBNB3009 balance\r\n     * 2. User signs EIP-3009 authorization (off-chain, no gas)\r\n     * 3. Facilitator calls this function (pays gas)\r\n     * 4. WBNB3009 transferred to contract\r\n     * 5. WBNB3009 unwrapped to BNB\r\n     * 6. BNB sent to PredictionMarket for bet\r\n     * 7. User paid ZERO gas!\r\n     */\r\n    function gaslessBetWithBNB(\r\n        uint256 marketId,\r\n        bool position,\r\n        address from,\r\n        uint256 wbnbValue,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        // Only facilitator can execute (gas sponsor)\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator\");\r\n        \r\n        // Check nonce not used\r\n        require(!usedNonces[nonce], \"Nonce already used\");\r\n        usedNonces[nonce] = true;\r\n        \r\n        uint256 gasStart = gasleft();\r\n        \r\n        // Calculate amounts\r\n        uint256 feeAmount = (wbnbValue * facilitatorFee) / 10000;\r\n        uint256 betAmount = wbnbValue - feeAmount;\r\n        \r\n        // Execute EIP-3009 transfer (WBNB3009 from user to contract)\r\n        wbnb.transferWithAuthorization(\r\n            from,\r\n            address(this),\r\n            wbnbValue,\r\n            validAfter,\r\n            validBefore,\r\n            nonce,\r\n            signature\r\n        );\r\n        \r\n        // Unwrap WBNB3009 → BNB\r\n        wbnb.withdraw(betAmount);\r\n        \r\n        // Place bet with native BNB\r\n        predictionMarket.buyPositionForUser{value: betAmount}(\r\n            marketId,\r\n            position,\r\n            from\r\n        );\r\n        \r\n        // Track gas used (for analytics)\r\n        uint256 gasUsed = (gasStart - gasleft()) * tx.gasprice;\r\n        gasCredits[from] += gasUsed;\r\n        \r\n        emit GaslessBetPlaced(marketId, from, position, betAmount, nonce);\r\n        emit GasSponsored(from, gasUsed);\r\n    }\r\n    \r\n    /**\r\n     * @dev Batch gasless bets (multiple bets in one tx)\r\n     * @notice Even more efficient - spread gas cost across multiple bets!\r\n     */\r\n    function batchGaslessBets(\r\n        uint256[] calldata marketIds,\r\n        bool[] calldata positions,\r\n        address[] calldata froms,\r\n        uint256[] calldata wbnbValues,\r\n        uint256[] calldata validAfters,\r\n        uint256[] calldata validBefores,\r\n        bytes32[] calldata nonces,\r\n        bytes[] calldata signatures\r\n    ) external nonReentrant {\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator\");\r\n        require(\r\n            marketIds.length == positions.length &&\r\n            positions.length == froms.length &&\r\n            froms.length == wbnbValues.length &&\r\n            wbnbValues.length == nonces.length &&\r\n            nonces.length == signatures.length,\r\n            \"Array length mismatch\"\r\n        );\r\n        \r\n        for (uint256 i = 0; i < marketIds.length; i++) {\r\n            // Check nonce\r\n            require(!usedNonces[nonces[i]], \"Nonce already used\");\r\n            usedNonces[nonces[i]] = true;\r\n            \r\n            uint256 feeAmount = (wbnbValues[i] * facilitatorFee) / 10000;\r\n            uint256 betAmount = wbnbValues[i] - feeAmount;\r\n            \r\n            // Transfer WBNB3009\r\n            wbnb.transferWithAuthorization(\r\n                froms[i],\r\n                address(this),\r\n                wbnbValues[i],\r\n                validAfters[i],\r\n                validBefores[i],\r\n                nonces[i],\r\n                signatures[i]\r\n            );\r\n            \r\n            // Unwrap and bet\r\n            wbnb.withdraw(betAmount);\r\n            predictionMarket.buyPositionForUser{value: betAmount}(\r\n                marketIds[i],\r\n                positions[i],\r\n                froms[i]\r\n            );\r\n            \r\n            emit GaslessBetPlaced(marketIds[i], froms[i], positions[i], betAmount, nonces[i]);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev GASLESS CLAIM with EIP-712 signature\r\n     * @notice User signs claim authorization, facilitator executes\r\n     * User receives BNB directly, pays ZERO gas!\r\n     */\r\n    function gaslessClaim(\r\n        uint256 marketId,\r\n        address user,\r\n        bytes32 nonce,\r\n        bytes memory signature\r\n    ) external nonReentrant {\r\n        require(msg.sender == facilitator || msg.sender == owner(), \"Only facilitator\");\r\n        require(!usedNonces[nonce], \"Nonce already used\");\r\n        \r\n        // TODO: Verify EIP-712 signature for claim authorization\r\n        // For now, trust facilitator (in production, add signature verification)\r\n        \r\n        usedNonces[nonce] = true;\r\n        \r\n        // Claim winnings to this contract\r\n        uint256 balanceBefore = address(this).balance;\r\n        predictionMarket.claimWinnings(marketId);\r\n        uint256 winnings = address(this).balance - balanceBefore;\r\n        \r\n        // Transfer winnings to user\r\n        (bool success, ) = user.call{value: winnings}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Set facilitator address\r\n     */\r\n    function setFacilitator(address _facilitator) external onlyOwner {\r\n        facilitator = _facilitator;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set facilitator fee (in basis points, e.g. 50 = 0.5%)\r\n     */\r\n    function setFacilitatorFee(uint256 _fee) external onlyOwner {\r\n        require(_fee <= 500, \"Fee too high\"); // Max 5%\r\n        facilitatorFee = _fee;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency withdraw BNB (only owner)\r\n     */\r\n    function emergencyWithdraw() external onlyOwner {\r\n        (bool success, ) = owner().call{value: address(this).balance}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Receive BNB from WBNB unwrapping\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}